-- Translation of action descriptions from Actions You Can Handle into open 
-- lolli propositions in Adjoint Logic
open import Data.List
open import Data.Product renaming (_,_ to âŸ¨_,_âŸ©)
open import Relation.Binary.Definitions using (DecidableEquality)
open import Data.Bool hiding (_â‰Ÿ_)
open import Relation.Nullary using (Â¬_; Dec; yes; no; does; contradiction; contraposition)
open import Relation.Nullary.Negation
import Relation.Binary.PropositionalEquality as Eq
open Eq using (_â‰¡_; refl; cong)
open import Data.List.Relation.Binary.Sublist.Heterogeneous.Core using (_âˆ·Ê³_) renaming ([] to âˆ…)
open import Data.String hiding (_++_; length) renaming (_â‰Ÿ_ to _â‰Ÿâ‚›_)
open import Data.Nat using (â„•; suc; zero; _+_) renaming (_â‰Ÿ_ to _â‰Ÿâ‚™_)
open import Data.Fin hiding (_+_)
open import Data.Vec

module Translations.Core.Operator where
  open import STRIPS.Problem hiding (Term)
  open import Translations.Core.Condition
  open import Translations.Core.State
  open import Logic.Core.Props Proposition
  open import Logic.Core.Terms TermAtom
  open import Logic.Core.Modes
  open import Logic.Utils.ModeOf Proposition

  private
    -- Prepends n âˆ€'s before the given Prop
    prependForAlls : âˆ€ ( n : â„• ) â†’ Prop â†’ Prop
    prependForAlls zero P = P
    prependForAlls (suc c) P = âˆ€[ prependForAlls c P ]

    -- Constructs an implication with universally quantified variables out of an operator o.
    translPs : âˆ€ ( o : Operator ) 
                â†’ â„• -- The count of truth value variables generated by the translation, to be initialized with zero
                â†’ List (Condition (Operator.arity o)) -- To be initialized with all conditions of o
                â†’ Prop -- To be initialized with ğŸ™, and meant to be âŠ—â€²d with translations of preconditions of o
                â†’ Prop -- To be initialized with ğŸ™, and meant to be âŠ—'d with translations of postconditions of o
                â†’ Prop

    translPs o tvc [] PL PR = prependForAlls ((Operator.arity o) + tvc) (PL âŠ¸ PR)
    translPs o tvc (p âˆ· Ps) PL PR with (p âˆˆá¶œáµ‡ (o âº âˆ©á¶œ o â‚Š))
    ... | true = translPs o tvc Ps (` v[ translC p , const "true" ] âŠ— PL) (` v[ translC p , const "true" ] âŠ— PR)
    ... | false with (p âˆˆá¶œáµ‡ (o â» âˆ©á¶œ o â‚Š))
    ... | true = translPs o tvc Ps (` v[ translC p , const "false" ] âŠ— PL) (` v[ translC p , const "true" ] âŠ— PR)
    ... | false with (p âˆˆá¶œáµ‡ (o âº âˆ©á¶œ o â‚‹))
    ... | true = translPs o tvc Ps (` v[ translC p , const "true" ] âŠ— PL) (` v[ translC p , const "false" ] âŠ— PR)
    ... | false with (p âˆˆá¶œáµ‡ (o â» âˆ©á¶œ o â‚‹))
    ... | true = translPs o tvc Ps (` v[ translC p , const "false" ] âŠ— PL) (` v[ translC p , const "false" ] âŠ— PR)
    ... | false with ((p âˆˆá¶œáµ‡ o âº)) âˆ§ (not ((p âˆˆá¶œáµ‡ posts o)))
    ... | true = translPs o tvc Ps (` v[ translC p , const "true" ] âŠ— PL) (` v[ translC p , const "true" ] âŠ— PR)
    ... | false with ((p âˆˆá¶œáµ‡ o â»)) âˆ§ (not ((p âˆˆá¶œáµ‡ posts o)))
    ... | true = translPs o tvc Ps (` v[ translC p , const "false" ] âŠ— PL) (` v[ translC p , const "true" ] âŠ— PR)
    ... | false with ((p âˆˆá¶œáµ‡ o â‚Š)) âˆ§ (not ((p âˆˆá¶œáµ‡ pres o)))
    ... | true = translPs o (suc tvc) Ps (` v[ translC p , var ((Operator.arity o) + tvc) ] âŠ— PL) (` v[ translC p , const "true" ] âŠ— PR)
    ... | false = translPs o (suc tvc) Ps (` v[ translC p , var ((Operator.arity o) + tvc) ] âŠ— PL) (` v[ translC p , const "false" ] âŠ— PR)
  
  {- 
    Given an operator, translates into a universally quantified unrestricted implication. 
    See the pretty-printed translation example below for what this is supposed to look like.
  -}
  translO : Operator â†’ Prop Ã— Mode
  translO o = âŸ¨ (translPs o zero ((o âº âˆªá¶œ o â») âˆªá¶œ (o â‚Š âˆªá¶œ o â‚‹)) ğŸ™ ğŸ™) , Unrestricted âŸ©

  translOs : (O : List Operator) â†’ Vec (Prop Ã— Mode) (Data.List.length O)
  translOs [] = []
  translOs (x âˆ· O) = translO x âˆ· translOs O 

  -- Let's test translO
  private
    o : Operator
    o = record
      { label = "stack"
      ; arity = 2
      ; posPre = (record { name = "holding" 
                        ; terms = var zero âˆ· [] }) âˆ· 
                  record { name = "clear" 
                        ; terms = var (suc zero) âˆ· [] } 
                  âˆ· []
      ; negPre = []
      ; posPost = (record { name = "clear" 
                        ; terms = var zero âˆ· [] }) âˆ· 
                  record { name = "handempty" 
                        ; terms = [] } âˆ· 
                  record { name = "on"
                        ; terms = var zero âˆ· var (suc zero) âˆ· [] } âˆ· []
      ; negPost = (record { name = "holding" 
                        ; terms = var zero âˆ· [] }) âˆ· 
                  record { name = "clear" 
                        ; terms = var (suc zero) âˆ· [] } 
                  âˆ· []
      }

  o-trans : Prop Ã— Mode
  o-trans = translO o
  
  open import PrettyPrinter.PrettyPrinter 3000

  -- Pretty printing the result instead of using an equality test because
  -- writing the result out by hand is very tedious.
  o-trans-str = render (prettyProp (projâ‚ o-trans)) 
