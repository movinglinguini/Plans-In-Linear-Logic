-- Translation of action descriptions from Actions You Can Handle into open 
-- lolli propositions in Adjoint Logic
open import Data.List
open import Data.Product renaming (_,_ to âŸ¨_,_âŸ©)
open import Relation.Binary.Definitions using (DecidableEquality)
open import Data.Bool hiding (_â‰Ÿ_)
open import Relation.Nullary using (Â¬_; Dec; yes; no; does; contradiction; contraposition)
open import Relation.Nullary.Negation
import Relation.Binary.PropositionalEquality as Eq
open Eq using (_â‰¡_; refl; cong)
open import Data.List.Relation.Binary.Sublist.Heterogeneous.Core using (_âˆ·Ê³_) renaming ([] to âˆ…)
open import Data.String hiding (_++_; length) renaming (_â‰Ÿ_ to _â‰Ÿâ‚›_)
open import Data.Nat using (â„•; suc; zero; _+_) renaming (_â‰Ÿ_ to _â‰Ÿâ‚™_)
open import Data.Nat.Properties
open import Data.Fin hiding (_+_)
open import Data.Vec hiding (length)

module Translations.Core.Operator where
  open import STRIPS.Problem hiding (Term)
  open import Translations.Core.Condition
  open import Translations.Core.State
  open import Logic.Core.Props PropAtom
  open import Logic.Core.Terms TermAtom
  open import Logic.Core.Modes
  open import Logic.Utils.ModeOf PropAtom

  private
    translPs-lift-cond : âˆ€ { o } (n : â„•) â†’ o Data.Nat.â‰¤ n â†’ Condition o â†’ TCondition n
    translPs-lift-cond n oâ‰¤n C = translCâ€² n oâ‰¤n C

    translPs-lift : âˆ€ { o } (n : â„•) â†’ o Data.Nat.â‰¤ n â†’ Condition o â†’ Fin n â†’ Prop
    translPs-lift n oâ‰¤n C tv = ` v[ translPs-lift-cond n oâ‰¤n C , var tv ]

    -- Constructs an implication with universally quantified variables out of an operator o.
    translPs : âˆ€ ( o : Operator ) 
                â†’ (varCount : â„•) -- The count of truth value variables generated by the translation, to be initialized with zero
                â†’ (Operator.arity o) Data.Nat.â‰¤ varCount
                â†’ List (Condition (Operator.arity o)) -- To be initialized with all conditions of o
                â†’ Prop -- To be initialized with ğŸ™, and meant to be âŠ—â€²d with translations of preconditions of o
                â†’ Prop -- To be initialized with ğŸ™, and meant to be âŠ—'d with translations of postconditions of o
                â†’ Prop
    translPs o zero oâ‰¤vc [] PL PR = PL âŠ¸ PR
    translPs o (suc vc) oâ‰¤vc [] PL PR = âˆ€[ vc ][ PL âŠ¸ PR ]
    translPs o vc oâ‰¤vc (p âˆ· Ps) PL PR with (p âˆˆá¶œáµ‡ (o âº âˆ©á¶œ o â‚Š))
    ... | true = translPs o vc oâ‰¤vc Ps (` v[ translC p , const "true" ] âŠ— PL) (` v[ translC p , const "true" ] âŠ— PR)
    ... | false with (p âˆˆá¶œáµ‡ (o â» âˆ©á¶œ o â‚Š))
    ... | true = translPs o vc oâ‰¤vc Ps (` v[ translC p , const "false" ] âŠ— PL) (` v[ translC p , const "true" ] âŠ— PR)
    ... | false with (p âˆˆá¶œáµ‡ (o âº âˆ©á¶œ o â‚‹))
    ... | true = translPs o vc oâ‰¤vc Ps (` v[ translC p , const "true" ] âŠ— PL) (` v[ translC p , const "false" ] âŠ— PR)
    ... | false with (p âˆˆá¶œáµ‡ (o â» âˆ©á¶œ o â‚‹))
    ... | true = translPs o vc oâ‰¤vc Ps (` v[ translC p , const "false" ] âŠ— PL) (` v[ translC p , const "false" ] âŠ— PR)
    ... | false with ((p âˆˆá¶œáµ‡ o âº)) âˆ§ (not ((p âˆˆá¶œáµ‡ posts o)))
    ... | true = translPs o vc oâ‰¤vc Ps (` v[ translC p , const "true" ] âŠ— PL) (` v[ translC p , const "true" ] âŠ— PR)
    ... | false with ((p âˆˆá¶œáµ‡ o â»)) âˆ§ (not ((p âˆˆá¶œáµ‡ posts o)))
    ... | true = translPs o vc oâ‰¤vc Ps (` v[ translC p , const "false" ] âŠ— PL) (` v[ translC p , const "true" ] âŠ— PR)
    ... | false with ((p âˆˆá¶œáµ‡ o â‚Š)) âˆ§ (not ((p âˆˆá¶œáµ‡ pres o)))
    ... | true = 
      let oâ‰¤svc = â‰¤-trans oâ‰¤vc (nâ‰¤1+n vc)
       in translPs o (suc vc) oâ‰¤svc Ps (translPs-lift (suc vc) oâ‰¤svc p (fromâ„• vc) âŠ— PL) (` v[ translC p , const "true" ] âŠ— PR)
    ... | false = 
      let oâ‰¤svc = â‰¤-trans oâ‰¤vc (nâ‰¤1+n vc)
       in translPs o (suc vc) oâ‰¤svc Ps (translPs-lift (suc vc) oâ‰¤svc p (fromâ„• vc) âŠ— PL) (` v[ translC p , const "false" ] âŠ— PR)
  
    {- 
    Given an operator, translates into a universally quantified unrestricted implication. 
    See the pretty-printed translation example below for what this is supposed to look like.
    -}
    translO-Operator : Operator â†’ Prop Ã— Mode
    translO-Operator o = âŸ¨ translPs o (Operator.arity o) â‰¤-refl ((o âº âˆªá¶œ o â») âˆªá¶œ (o â‚Š âˆªá¶œ o â‚‹)) ğŸ™ ğŸ™ , Unrestricted âŸ©

    translO-Operators : ( os : List Operator ) â†’ Vec (Prop Ã— Mode) (length os)
    translO-Operators [] = []
    translO-Operators (o âˆ· os) = translO-Operator o âˆ· translO-Operators os

  translO : âˆ€ { ğ•‹ â„‚ ğ•€ ğ•† ğ”¾ } â†’ PlanProblem ğ•‹ â„‚ ğ•€ ğ•† ğ”¾  â†’ Vec (Prop Ã— Mode) (length ğ•†)
  translO (wf/prob _ _ _ ğ•† _ _) = translO-Operators ğ•†

  -- Let's test translO
  private
    o : Operator
    o = record
      { label = "stack"
      ; arity = 2
      ; posPre = (record { name = "holding" 
                        ; terms = var zero âˆ· [] }) âˆ· 
                  record { name = "clear" 
                        ; terms = var (suc zero) âˆ· [] } 
                  âˆ· []
      ; negPre = []
      ; posPost = (record { name = "clear" 
                        ; terms = var zero âˆ· [] }) âˆ· 
                  record { name = "handempty" 
                        ; terms = [] } âˆ· 
                  record { name = "on"
                        ; terms = var zero âˆ· var (suc zero) âˆ· [] } âˆ· []
      ; negPost = (record { name = "holding" 
                        ; terms = var zero âˆ· [] }) âˆ· 
                  record { name = "clear" 
                        ; terms = var (suc zero) âˆ· [] } 
                  âˆ· []
      }

  o-trans : Prop Ã— Mode
  o-trans = translO-Operator o
  
  open import PrettyPrinter.PrettyPrinter 3000

  -- Pretty printing the result instead of using an equality test because
  -- writing the result out by hand is very tedious.
  o-trans-str = render (prettyProp (projâ‚ o-trans)) 
 