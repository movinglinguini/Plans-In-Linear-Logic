-- Translation of action descriptions from Actions You Can Handle into open 
-- lolli propositions in Adjoint Logic
open import Data.List
open import Data.Product renaming (_,_ to ⟨_,_⟩)
open import Relation.Binary.Definitions using (DecidableEquality)
open import Data.Bool hiding (_≟_)
open import Relation.Nullary using (¬_; Dec; yes; no; does; contradiction; contraposition)
open import Relation.Nullary.Negation
import Relation.Binary.PropositionalEquality as Eq
open Eq using (_≡_; refl; cong)
open import Data.List.Relation.Binary.Sublist.Heterogeneous.Core using (_∷ʳ_) renaming ([] to ∅)
open import Data.String hiding (_++_; length) renaming (_≟_ to _≟ₛ_)
open import Data.Nat using (ℕ; suc; zero; _+_) renaming (_≟_ to _≟ₙ_)
open import Data.Nat.Properties
open import Data.Fin hiding (_+_)
open import Data.Vec hiding (length)

module Translations.Core.Operator where
  open import STRIPS.Problem hiding (Term)
  open import Translations.Core.Condition
  open import Translations.Core.State
  open import Logic.Core.Props PropAtom
  open import Logic.Core.Terms TermAtom
  open import Logic.Core.Modes
  open import Logic.Utils.ModeOf PropAtom

  private
    translPs-lift-cond : ∀ { o } (n : ℕ) → o Data.Nat.≤ n → Condition o → TCondition n
    translPs-lift-cond n o≤n C = translC′ n o≤n C

    translPs-lift : ∀ { o } (n : ℕ) → o Data.Nat.≤ n → Condition o → Fin n → Prop
    translPs-lift n o≤n C tv = ` v[ translPs-lift-cond n o≤n C , var tv ]

    -- Constructs an implication with universally quantified variables out of an operator o.
    translPs : ∀ ( o : Operator ) 
                → (varCount : ℕ) -- The count of truth value variables generated by the translation, to be initialized with zero
                → (Operator.arity o) Data.Nat.≤ varCount
                → List (Condition (Operator.arity o)) -- To be initialized with all conditions of o
                → Prop -- To be initialized with 𝟙, and meant to be ⊗′d with translations of preconditions of o
                → Prop -- To be initialized with 𝟙, and meant to be ⊗'d with translations of postconditions of o
                → Prop
    translPs o zero o≤vc [] PL PR = PL ⊸ PR
    translPs o (suc vc) o≤vc [] PL PR = ∀[ vc ][ PL ⊸ PR ]
    translPs o vc o≤vc (p ∷ Ps) PL PR with (p ∈ᶜᵇ (o ⁺ ∩ᶜ o ₊))
    ... | true = translPs o vc o≤vc Ps (` v[ translC p , const "true" ] ⊗ PL) (` v[ translC p , const "true" ] ⊗ PR)
    ... | false with (p ∈ᶜᵇ (o ⁻ ∩ᶜ o ₊))
    ... | true = translPs o vc o≤vc Ps (` v[ translC p , const "false" ] ⊗ PL) (` v[ translC p , const "true" ] ⊗ PR)
    ... | false with (p ∈ᶜᵇ (o ⁺ ∩ᶜ o ₋))
    ... | true = translPs o vc o≤vc Ps (` v[ translC p , const "true" ] ⊗ PL) (` v[ translC p , const "false" ] ⊗ PR)
    ... | false with (p ∈ᶜᵇ (o ⁻ ∩ᶜ o ₋))
    ... | true = translPs o vc o≤vc Ps (` v[ translC p , const "false" ] ⊗ PL) (` v[ translC p , const "false" ] ⊗ PR)
    ... | false with ((p ∈ᶜᵇ o ⁺)) ∧ (not ((p ∈ᶜᵇ posts o)))
    ... | true = translPs o vc o≤vc Ps (` v[ translC p , const "true" ] ⊗ PL) (` v[ translC p , const "true" ] ⊗ PR)
    ... | false with ((p ∈ᶜᵇ o ⁻)) ∧ (not ((p ∈ᶜᵇ posts o)))
    ... | true = translPs o vc o≤vc Ps (` v[ translC p , const "false" ] ⊗ PL) (` v[ translC p , const "true" ] ⊗ PR)
    ... | false with ((p ∈ᶜᵇ o ₊)) ∧ (not ((p ∈ᶜᵇ pres o)))
    ... | true = 
      let o≤svc = ≤-trans o≤vc (n≤1+n vc)
       in translPs o (suc vc) o≤svc Ps (translPs-lift (suc vc) o≤svc p (fromℕ vc) ⊗ PL) (` v[ translC p , const "true" ] ⊗ PR)
    ... | false = 
      let o≤svc = ≤-trans o≤vc (n≤1+n vc)
       in translPs o (suc vc) o≤svc Ps (translPs-lift (suc vc) o≤svc p (fromℕ vc) ⊗ PL) (` v[ translC p , const "false" ] ⊗ PR)
  
    {- 
    Given an operator, translates into a universally quantified unrestricted implication. 
    See the pretty-printed translation example below for what this is supposed to look like.
    -}
    translO-Operator : Operator → Prop × Mode
    translO-Operator o = ⟨ translPs o (Operator.arity o) ≤-refl ((o ⁺ ∪ᶜ o ⁻) ∪ᶜ (o ₊ ∪ᶜ o ₋)) 𝟙 𝟙 , Unrestricted ⟩

    translO-Operators : ( os : List Operator ) → Vec (Prop × Mode) (length os)
    translO-Operators [] = []
    translO-Operators (o ∷ os) = translO-Operator o ∷ translO-Operators os

  translO : ∀ { 𝕋 ℂ 𝕀 𝕆 𝔾 } → PlanProblem 𝕋 ℂ 𝕀 𝕆 𝔾  → Vec (Prop × Mode) (length 𝕆)
  translO (wf/prob _ _ _ 𝕆 _ _) = translO-Operators 𝕆

  -- Let's test translO
  private
    o : Operator
    o = record
      { label = "stack"
      ; arity = 2
      ; posPre = (record { name = "holding" 
                        ; terms = var zero ∷ [] }) ∷ 
                  record { name = "clear" 
                        ; terms = var (suc zero) ∷ [] } 
                  ∷ []
      ; negPre = []
      ; posPost = (record { name = "clear" 
                        ; terms = var zero ∷ [] }) ∷ 
                  record { name = "handempty" 
                        ; terms = [] } ∷ 
                  record { name = "on"
                        ; terms = var zero ∷ var (suc zero) ∷ [] } ∷ []
      ; negPost = (record { name = "holding" 
                        ; terms = var zero ∷ [] }) ∷ 
                  record { name = "clear" 
                        ; terms = var (suc zero) ∷ [] } 
                  ∷ []
      }

  o-trans : Prop × Mode
  o-trans = translO-Operator o
  
  open import PrettyPrinter.PrettyPrinter 3000

  -- Pretty printing the result instead of using an equality test because
  -- writing the result out by hand is very tedious.
  o-trans-str = render (prettyProp (proj₁ o-trans)) 
 